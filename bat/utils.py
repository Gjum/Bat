def run_task(task, event_plugin, callback=None):
    """
    Run the task, that is:
    - subscribe to event names that are generated by the task
    - when the event is emitted, send the event data to the generator
    :param task: generator, which generates event names
    :param event_plugin: plugin which handles all events, must provide .reg_event_handler() method
    :param callback: optional, called with task's return value when the task is finished
    :return: first generated value of the generator, or its return value if stopped immediately, or None if no generator
    """

    listening = []

    def register(response):
        listening.clear()
        # response might be list or tuple of event names
        if isinstance(response, list) or isinstance(response, tuple):
            listening.extend(response)
        else:  # event name string or other unique value
            listening.append(response)
        # functions that otherwise return response event names
        # may return these when no event subscription is needed
        non_events = (True, False, None)
        for event in listening:
            if event in non_events:
                listening.clear()
                handler(event, {'response': event}, force=True)
                break
            else:
                event_plugin.reg_event_handler(event, handler)

    def handler(evt, data, force=False):
        if not force and evt not in listening:
            return True
        try:
            response = task.send((evt, data))
        except StopIteration as e:
            if callback:
                callback(e.value)
        else:
            register(response)
        return True  # remove this handler

    try:
        response = next(task)
    except TypeError:  # task is no generator
        return None
    except StopIteration as e:  # returned immediately
        if callback:
            callback(e.value)
        return e.value
    else:
        register(response)
    return response
